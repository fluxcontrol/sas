#!/bin/sh

################################################################################
### REGISTER DEFINITIONS
###   define register values, operand match sets, etc.
################################################################################
eax=0
 ax=0
 al=0
ebx=3
 bx=3
 bl=3
ecx=1
 cx=1
 cl=1
edx=2
 dx=2
 dl=2

 ah=4
 bh=7
 ch=5
 dh=6

esp=4
 sp=4
 sl=4
ebp=5
 bp=5
 bl=5
esi=6
 si=6
sil=6
edi=7
 di=7
dil=4

es=0
cs=1
ss=2
ds=3

fs=4
gs=5

# used for matching
reg32="e?[xip]"
reg16="?[xip]"
reg8="?[hl]"
imm32="[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]"
imm16="[0-9a-f][0-9a-f][0-9a-f][0-9a-f]"
imm8="[0-9a-f][0-9a-f]"
imm32d="[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]d"
imm16d="[0-9][0-9][0-9][0-9]d"
imm8d="[0-2][0-9][0-9]d"
imm32b="[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01]b"
imm16b="[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01]b"
imm8b="[01][01][01][01][01][01][01][01]b"

################################################################################
### MNEMONICS (ASM INSTRUCTIONS)
###   the "standard" x86 intel instruction mnemonics (yes, intel syntax, no
###   gas)
################################################################################
instr_nop() {
	args 0 || return 1
	assemble 90
}

instr_sahf() {
	args 0 || return 1
	assemble 9e
}

instr_lahf() {
	args 0 || return 1
	assemble 9f
}

instr_pushf() {
	args 0 || return 1
	assemble 9c
}

instr_pushfd() {
	args 0 || return 1
	assemble 9c
}

instr_popf() {
	args 0 || return 1
	assemble 9d
}

instr_popfd() {
	args 0 || return 1
	assemble 9d
}

instr_rol() {
	args 2 || return 1
	if [ "$2" = "1" ]
	then
		case "$1" in
			$reg32) assemble d1 $(hexadd c0 $(get_reg $1)) ;;
			$reg16) assemble 66 d1 $(hexadd c0 $(get_reg $1)) ;;
			$reg8) assemble d0 $(hexadd c0 $(get_reg $1)) ;;
			*) return 1 ;;
		esac
	else
		case "$1" in
			$reg32) assemble c1 $(hexadd c0 $(get_reg $1)) $(num $2) ;;
			$reg16) assemble 66 c1 $(hexadd c0 $(get_reg $1)) $(num $2) ;;
			$reg8) assemble c0 $(hexadd c0 $(get_reg $1)) $(num $2) ;;
			*) return 1 ;;
		esac
	fi
}

instr_ror() {
	args 2 || return 1
	if [ "$2" = "1" ]
	then
		case "$1" in
			$reg32) assemble d1 $(hexadd c8 $(get_reg $1)) ;;
			$reg16) assemble 66 d1 $(hexadd c8 $(get_reg $1)) ;;
			$reg8) assemble d0 $(hexadd c8 $(get_reg $1)) ;;
			*) return 1 ;;
		esac
	else
		case "$1" in
			$reg32) assemble c1 $(hexadd c8 $(get_reg $1)) $(num $2) ;;
			$reg16) assemble 66 c1 $(hexadd c8 $(get_reg $1)) $(num $2) ;;
			$reg8) assemble c0 $(hexadd c8 $(get_reg $1)) $(num $2) ;;
			*) return 1 ;;
		esac
	fi
}

instr_shl() {
	args 2 || return 1
	if [ "$2" = "1" ]
	then
		case "$1" in
			$reg32) assemble d1 $(hexadd e0 $(get_reg $1)) ;;
			$reg16) assemble 66 d1 $(hexadd e0 $(get_reg $1)) ;;
			$reg8) assemble d0 $(hexadd e0 $(get_reg $1)) ;;
			*) return 1 ;;
		esac
	else
		case "$1" in
			$reg32) assemble c1 $(hexadd e0 $(get_reg $1)) $(num $2) ;;
			$reg16) assemble 66 c1 $(hexadd e0 $(get_reg $1)) $(num $2) ;;
			$reg8) assemble c0 $(hexadd e0 $(get_reg $1)) $(num $2) ;;
			*) return 1 ;;
		esac
	fi
}

instr_shr() {
	args 2 || return 1
	if [ "$2" = "1" ]
	then
		case "$1" in
			$reg32) assemble d1 $(hexadd e8 $(get_reg $1)) ;;
			$reg16) assemble 66 d1 $(hexadd e8 $(get_reg $1)) ;;
			$reg8) assemble d0 $(hexadd e8 $(get_reg $1)) ;;
			*) return 1 ;;
		esac
	else
		case "$1" in
			$reg32) assemble c1 $(hexadd e8 $(get_reg $1)) $(num $2) ;;
			$reg16) assemble 66 c1 $(hexadd e8 $(get_reg $1)) $(num $2) ;;
			$reg8) assemble c0 $(hexadd e8 $(get_reg $1)) $(num $2) ;;
			*) return 1 ;;
		esac
	fi
}

instr_sal() {
	args 2 || return 1
	if [ "$2" = "1" ]
	then
		case "$1" in
			$reg32) assemble d1 $(hexadd e0 $(get_reg $1)) ;;
			$reg16) assemble 66 d1 $(hexadd e0 $(get_reg $1)) ;;
			$reg8) assemble d0 $(hexadd e0 $(get_reg $1)) ;;
			*) return 1 ;;
		esac
	else
		case "$1" in
			$reg32) assemble c1 $(hexadd e0 $(get_reg $1)) $(num $2) ;;
			$reg16) assemble 66 c1 $(hexadd e0 $(get_reg $1)) $(num $2) ;;
			$reg8) assemble c0 $(hexadd e0 $(get_reg $1)) $(num $2) ;;
			*) return 1 ;;
		esac
	fi
}

instr_sar() {
	args 2 || return 1
	if [ "$2" = "1" ]
	then
		case "$1" in
			$reg32) assemble d1 $(hexadd f8 $(get_reg $1)) ;;
			$reg16) assemble 66 d1 $(hexadd f8 $(get_reg $1)) ;;
			$reg8) assemble d0 $(hexadd f8 $(get_reg $1)) ;;
			*) return 1 ;;
		esac
	else
		case "$1" in
			$reg32) assemble c1 $(hexadd f8 $(get_reg $1)) $(num $2) ;;
			$reg16) assemble 66 c1 $(hexadd f8 $(get_reg $1)) $(num $2) ;;
			$reg8) assemble c0 $(hexadd f8 $(get_reg $1)) $(num $2) ;;
			*) return 1 ;;
		esac
	fi
}

instr_xchg() {
	args 2 || return 1
	case "$2" in
		eax) assemble $(hexadd 90 $(get_reg $1)) ;;
		$reg32)
			case "$1" in
				eax) assemble $(hexadd 90 $(get_reg $2)) ;;
				$reg32) assemble 87 $(hexadd c0 $(hexmult 8 $(get_reg $2)) $(get_reg $1)) ;;
				*) return 1 ;;
			esac
			;;
		ax) assemble 66 $(hexadd 90 $(get_reg $1)) ;;
		$reg16)
			case "$1" in
				ax) assemble 66 $(hexadd 90 $(get_reg $2)) ;;
				$reg16) assemble 66 87 $(hexadd c0 $(hexmult 8 $(get_reg $1)) $(get_reg $2)) ;;
				*) return 1 ;;
			esac
			;;
		$reg8)
			case "$1" in
				$reg8) assemble 86 $(hexadd c0 $(hexmult 8 $(get_reg $1)) $(get_reg $2)) ;;
				*) return 1 ;;
			esac
			;;
		*) return 1 ;;
	esac
}

instr_push() {
	case "$1" in
		byte)
			shift
			assemble 68 $(endian $(num "$1"))
			return 0
			;;
	esac

	args 1 || return 1
	case "$1" in
		es) assemble 06 ;;
		cs) assemble 0e ;;
		ss) assemble 16 ;;
		ds) assemble 1e ;;

		$reg32) assemble $(hexadd 50 $(get_reg $1)) ;;
		$reg16) assemble 66 $(hexadd 50 $(get_reg $1)) ;;
		$reg8) return 1 ;;
		*) assemble 68 $(endian $(num "$1")) ;;
	esac
}

instr_pop() {
	args 1 || return 1
	case "$1" in
		es) assemble 06 ;;
		cs) assemble 0e ;;
		ss) assemble 16 ;;
		ds) assemble 1e ;;

		$reg32) assemble $(hexadd 58 $(get_reg $1)) ;;
		$reg16) assemble 66 $(hexadd 58 $(get_reg $1)) ;;
		*) return 1 ;;
	esac
}

instr_inc() {
	args 1 || return 1
	case "$1" in
		$reg32) assemble $(hexadd 40 $(get_reg $1)) ;;
		$reg16) assemble 66 $(hexadd 40 $(get_reg $1)) ;;
		$reg8) assemble fe $(hexadd c0 $(get_reg $1)) ;;
		*) return 1 ;;
	esac
}

instr_dec() {
	args 1 || return 1
	case "$1" in
		$reg32) assemble $(hexadd 48 $(get_reg $1)) ;;
		$reg16) assemble 66 $(hexadd 48 $(get_reg $1)) ;;
		$reg8) assemble fe $(hexadd c8 $(get_reg $1)) ;;
		*) return 1 ;;
	esac
}

instr_xor() {
	args 2 || return 1
	case "$2" in
		$reg32)
			case "$1" in
				$reg32) assemble 31 $(hexadd c0 $(hexmult 8 $(get_reg $2)) $(get_reg $1)) ;;
				*) return 1 ;;
			esac
			;;
		$reg16)
			case "$1" in
				$reg16) assemble 66 31 $(hexadd c0 $(hexmult 8 $(get_reg $2)) $(get_reg $1)) ;;
				*) return 1 ;;
			esac
			;;
		$reg8)
			case "$1" in
				$reg8) assemble 30 $(hexadd c0 $(hexmult 8 $(get_reg $2)) $(get_reg $1)) ;;
				*) return 1 ;;
			esac
			;;
		*) return 1 ;;
	esac
}

instr_mov() {
	args 2 || return 1
	case "$2" in
		$reg32)
			case "$1" in
				$reg32) assemble 89 $(hexadd c0 $(hexmult 8 $(get_reg $2)) $(get_reg $1)) ;;
				*) return 1 ;;
			esac
			;;
		$reg16)
			case "$1" in
				$reg16) assemble 66 89 $(hexadd c0 $(hexmult 8 $(get_reg $2)) $(get_reg $1)) ;;
				*) return 1 ;;
			esac
			;;
		$reg8)
			case "$1" in
				$reg8) assemble 88 $(hexadd c0 $(hexmult 8 $(get_reg $2)) $(get_reg $1)) ;;
				*) return 1 ;;
			esac
			;;
		*) return 1 ;;
	esac
}

instr_int() {
	args 1 || return 1
	case "$1" in
		3) assemble cc ;;
		$imm8|${imm8}h|$imm8b) assemble cd $(endian $(num $1)) ;;
		*) return 1 ;;
	esac
}

instr_cdq() {
	args 0 || return 1
	assemble 99
}

instr_add() {
	:
}

instr_sub() {
	:
}

instr_call() {
	args 1 || return 1
	case "$1" in
		$reg32) assemble ff $(hexadd d0 $(get_reg $1)) ;;
		$reg16) assemble 66 ff $(hexadd d0 $(get_reg $1)) ;;
		*) return 1 ;;
	esac
}

instr_jmp() {
	args 1 || return 1
	case "$1" in
		$reg32) assemble ff $(hexadd e0 $(get_reg $1)) ;;
		$reg16) assemble 66 ff $(hexadd e0 $(get_reg $1)) ;;
		*) return 1 ;;
	esac
}

instr_jz() {
	:
}

instr_jnz() {
	:
}

instr_jc() {
	:
}

instr_jnc() {
	:
}

instr_ja() {
	:
}

instr_jae() {
	:
}

instr_jb() {
	:
}

instr_jbe() {
	:
}

instr_jg() {
	:
}

instr_jge() {
	:
}

instr_jl() {
	:
}

instr_jle() {
	:
}

instr_foo() {
	:
}

instr_foo() {
	:
}

instr_foo() {
	:
}

instr_foo() {
	:
}

instr_foo() {
	:
}

instr_foo() {
	:
}

instr_foo() {
	:
}


