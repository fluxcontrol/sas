#!/bin/sh

################################################################################
### REGISTER DEFINITIONS
###   define register values, operand match sets, etc.
################################################################################
# general purpose registers
eax=0
 ax=0
 al=0
ebx=3
 bx=3
 bl=3
ecx=1
 cx=1
 cl=1
edx=2
 dx=2
 dl=2

# high 8-bit general purpose registers
 ah=4
 bh=7
 ch=5
 dh=6

# base/index registers
esp=4
 sp=4
 sl=4
ebp=5
 bp=5
 bl=5
esi=6
 si=6
sil=6
edi=7
 di=7
dil=4

# segment registers
es=0
cs=1
ss=2
ds=3
fs=4
gs=5

# used for matching
reg32="e?[xip]"
reg16="?[xip]"
reg8="?[hl]"

################################################################################
### MNEMONICS (ASM INSTRUCTIONS)
###   the "standard" x86 intel instruction mnemonics (yes, intel syntax, no
###   gas)
################################################################################
instr_nop() {
	args 0 || return 1
	assemble 90
}

instr_hlt() {
	args 0 || return 1
	assemble f4
}

instr_db() {
	args 0 && return 1
	while [ -n "$1" ]
	do
		assemble $(num "$1")
		shift
	done
}

instr_dw() {
	args 0 && return 1
	while [ -n "$1" ]
	do
		assemble $(endian $(tobytes $(pad 2 $(tohex "$1"))))
		shift
	done
}

instr_dd() {
	args 0 && return 1
	while [ -n "$1" ]
	do
		assemble $(endian $(tobytes $(pad 4 $(tohex "$1"))))
		shift
	done
}

#<<<<<<<<<<<<<<<<<<<<<<<<<
# flags
instr_sahf() {
	args 0 || return 1
	assemble 9e
}

instr_lahf() {
	args 0 || return 1
	assemble 9f
}

instr_pushf() {
	args 0 || return 1
	assemble 9c
}

instr_pushfd() {
	args 0 || return 1
	assemble 9c
}

instr_popf() {
	args 0 || return 1
	assemble 9d
}

instr_popfd() {
	args 0 || return 1
	assemble 9d
}

instr_clc() {
	args 0 || return 1
	assemble f8
}

instr_cld() {
	args 0 || return 1
	assemble fc
}

instr_stc() {
	args 0 || return 1
	assemble f9
}

instr_std() {
	args 0 || return 1
	assemble fd
}
#>>>>>>>>>>>>>>>>>>>>>>>>>

#<<<<<<<<<<<<<<<<<<<<<<<<<
# string ops
instr_cmpsb() {
	args 0 || return 1
	assemble a6
}

instr_cmpsw() {
	args 0 || return 1
	assemble 66 a7
}

instr_cmpsd() {
	args 0 || return 1
	assemble a7
}

instr_lodsb() {
	args 0 || return 1
	assemble ac
}

instr_lodsw() {
	args 0 || return 1
	assemble 66 ad
}

instr_lodsd() {
	args 0 || return 1
	assemble ad
}

instr_movsb() {
	args 0 || return 1
	assemble a4
}

instr_movsw() {
	args 0 || return 1
	assemble 66 a5
}

instr_movsd() {
	args 0 || return 1
	assemble a5
}

instr_scasb() {
	args 0 || return 1
	assemble ae
}

instr_scasw() {
	args 0 || return 1
	assemble 66 af
}

instr_scasd() {
	args 0 || return 1
	assemble af
}

instr_stosb() {
	args 0 || return 1
	assemble aa
}

instr_stosw() {
	args 0 || return 1
	assemble 66 ab
}

instr_stosd() {
	args 0 || return 1
	assemble ab
}
#>>>>>>>>>>>>>>>>>>>>>>>>>

#<<<<<<<<<<<<<<<<<<<<<<<<<
# repeats (loops)
instr_rep() {
	args 0 || return 1
	assemble f3
}

instr_repz() {
	args 0 || return 1
	assemble f3
}

instr_repe() {
	args 0 || return 1
	assemble f3
}

instr_repnz() {
	args 0 || return 1
	assemble f2
}

instr_repne() {
	args 0 || return 1
	assemble f2
}
#>>>>>>>>>>>>>>>>>>>>>>>>>

instr_pusha() {
	args 0 || return 1
	assemble 60
}

instr_pushad() {
	args 0 || return 1
	assemble 60
}

instr_popa() {
	args 0 || return 1
	assemble 61
}

instr_popad() {
	args 0 || return 1
	assemble 61
}

instr_aaa() {
	args 0 || return 1
	assemble 37
}

instr_aas() {
	args 0 || return 1
	assemble 3f
}

instr_cbw() {
	args 0 || return 1
	assemble 66 98
}

instr_cdq() {
	args 0 || return 1
	assemble 99
}

instr_cmc() {
	args 0 || return 1
	assemble f5
}

instr_cwd() {
	args 0 || return 1
	assemble 66 99
}

instr_cwde() {
	args 0 || return 1
	assemble 98
}

instr_daa() {
	args 0 || return 1
	assemble 27
}

instr_das() {
	args 0 || return 1
	assemble 2f
}

instr_xlat() {
	args 0 || return 1
	assemble d7
}

instr_ret() {
	args 0 || args 1 || return 1
	if [ -n "$1" ]
	then
		case "$1" in
			$hex*|0x$hex*|$hex*h|$bin*b|$dec*d)
				tohex "$1" 2 || return 1
				assemble c2 $(endian $(num $1))
				;;
			*)
				return 1
				;;
		esac
	else
		assemble c3
	fi
}

instr_retf() {
	args 0 || args 1 || return 1
	if [ -n "$1" ]
	then
		case "$1" in
			$hex*|0x$hex*|$hex*h|$bin*b|$dec*d)
				tohex "$1" 2 || return 1
				assemble ca $(endian $(num $1))
				;;
			*)
				return 1
				;;
		esac
	else
		assemble cb
	fi
}

instr_rol() {
	args 2 || return 1
	if [ "$2" = "1" ]
	then
		case "$1" in
			$reg32) assemble d1 $(hexadd c0 $(get_reg $1)) ;;
			$reg16) assemble 66 d1 $(hexadd c0 $(get_reg $1)) ;;
			$reg8) assemble d0 $(hexadd c0 $(get_reg $1)) ;;
			*) return 1 ;;
		esac
	else
		case "$1" in
			$reg32) assemble c1 $(hexadd c0 $(get_reg $1)) $(num $2) ;;
			$reg16) assemble 66 c1 $(hexadd c0 $(get_reg $1)) $(num $2) ;;
			$reg8) assemble c0 $(hexadd c0 $(get_reg $1)) $(num $2) ;;
			*) return 1 ;;
		esac
	fi
}

instr_ror() {
	args 2 || return 1
	if [ "$2" = "1" ]
	then
		case "$1" in
			$reg32) assemble d1 $(hexadd c8 $(get_reg $1)) ;;
			$reg16) assemble 66 d1 $(hexadd c8 $(get_reg $1)) ;;
			$reg8) assemble d0 $(hexadd c8 $(get_reg $1)) ;;
			*) return 1 ;;
		esac
	else
		case "$1" in
			$reg32) assemble c1 $(hexadd c8 $(get_reg $1)) $(num $2) ;;
			$reg16) assemble 66 c1 $(hexadd c8 $(get_reg $1)) $(num $2) ;;
			$reg8) assemble c0 $(hexadd c8 $(get_reg $1)) $(num $2) ;;
			*) return 1 ;;
		esac
	fi
}

instr_shl() {
	args 2 || return 1
	if [ "$2" = "1" ]
	then
		case "$1" in
			$reg32) assemble d1 $(hexadd e0 $(get_reg $1)) ;;
			$reg16) assemble 66 d1 $(hexadd e0 $(get_reg $1)) ;;
			$reg8) assemble d0 $(hexadd e0 $(get_reg $1)) ;;
			*) return 1 ;;
		esac
	else
		case "$1" in
			$reg32) assemble c1 $(hexadd e0 $(get_reg $1)) $(num $2) ;;
			$reg16) assemble 66 c1 $(hexadd e0 $(get_reg $1)) $(num $2) ;;
			$reg8) assemble c0 $(hexadd e0 $(get_reg $1)) $(num $2) ;;
			*) return 1 ;;
		esac
	fi
}

instr_shr() {
	args 2 || return 1
	if [ "$2" = "1" ]
	then
		case "$1" in
			$reg32) assemble d1 $(hexadd e8 $(get_reg $1)) ;;
			$reg16) assemble 66 d1 $(hexadd e8 $(get_reg $1)) ;;
			$reg8) assemble d0 $(hexadd e8 $(get_reg $1)) ;;
			*) return 1 ;;
		esac
	else
		case "$1" in
			$reg32) assemble c1 $(hexadd e8 $(get_reg $1)) $(num $2) ;;
			$reg16) assemble 66 c1 $(hexadd e8 $(get_reg $1)) $(num $2) ;;
			$reg8) assemble c0 $(hexadd e8 $(get_reg $1)) $(num $2) ;;
			*) return 1 ;;
		esac
	fi
}

instr_sal() {
	args 2 || return 1
	if [ "$2" = "1" ]
	then
		case "$1" in
			$reg32) assemble d1 $(hexadd e0 $(get_reg $1)) ;;
			$reg16) assemble 66 d1 $(hexadd e0 $(get_reg $1)) ;;
			$reg8) assemble d0 $(hexadd e0 $(get_reg $1)) ;;
			*) return 1 ;;
		esac
	else
		case "$1" in
			$reg32) assemble c1 $(hexadd e0 $(get_reg $1)) $(num $2) ;;
			$reg16) assemble 66 c1 $(hexadd e0 $(get_reg $1)) $(num $2) ;;
			$reg8) assemble c0 $(hexadd e0 $(get_reg $1)) $(num $2) ;;
			*) return 1 ;;
		esac
	fi
}

instr_sar() {
	args 2 || return 1
	if [ "$2" = "1" ]
	then
		case "$1" in
			$reg32) assemble d1 $(hexadd f8 $(get_reg $1)) ;;
			$reg16) assemble 66 d1 $(hexadd f8 $(get_reg $1)) ;;
			$reg8) assemble d0 $(hexadd f8 $(get_reg $1)) ;;
			*) return 1 ;;
		esac
	else
		case "$1" in
			$reg32) assemble c1 $(hexadd f8 $(get_reg $1)) $(num $2) ;;
			$reg16) assemble 66 c1 $(hexadd f8 $(get_reg $1)) $(num $2) ;;
			$reg8) assemble c0 $(hexadd f8 $(get_reg $1)) $(num $2) ;;
			*) return 1 ;;
		esac
	fi
}

instr_xchg() {
	args 2 || return 1
	case "$2" in
		eax) assemble $(hexadd 90 $(get_reg $1)) ;;
		$reg32)
			case "$1" in
				eax) assemble $(hexadd 90 $(get_reg $2)) ;;
				$reg32) assemble 87 $(hexadd c0 $(hexmult 8 $(get_reg $2)) $(get_reg $1)) ;;
				*) return 1 ;;
			esac
			;;
		ax) assemble 66 $(hexadd 90 $(get_reg $1)) ;;
		$reg16)
			case "$1" in
				ax) assemble 66 $(hexadd 90 $(get_reg $2)) ;;
				$reg16) assemble 66 87 $(hexadd c0 $(hexmult 8 $(get_reg $1)) $(get_reg $2)) ;;
				*) return 1 ;;
			esac
			;;
		$reg8)
			case "$1" in
				$reg8) assemble 86 $(hexadd c0 $(hexmult 8 $(get_reg $1)) $(get_reg $2)) ;;
				*) return 1 ;;
			esac
			;;
		*) return 1 ;;
	esac
}

instr_push() {
	case "$1" in
		byte)
			shift
			tohex "$1" 1 || return 1
			assemble 6a $(endian $(num "$1"))
			return 0
			;;
	esac

	args 1 || return 1
	case "$1" in
		es) assemble 06 ;;
		cs) assemble 0e ;;
		ss) assemble 16 ;;
		ds) assemble 1e ;;

		$reg32) assemble $(hexadd 50 $(get_reg $1)) ;;
		$reg16) assemble 66 $(hexadd 50 $(get_reg $1)) ;;
		$reg8) return 1 ;;
		*) assemble 68 $(endian $(num "$1")) ;;
	esac
}

instr_pop() {
	args 1 || return 1
	case "$1" in
		es) assemble 06 ;;
		cs) assemble 0e ;;
		ss) assemble 16 ;;
		ds) assemble 1e ;;

		$reg32) assemble $(hexadd 58 $(get_reg $1)) ;;
		$reg16) assemble 66 $(hexadd 58 $(get_reg $1)) ;;
		*) return 1 ;;
	esac
}

instr_inc() {
	args 1 || return 1
	case "$1" in
		$reg32) assemble $(hexadd 40 $(get_reg $1)) ;;
		$reg16) assemble 66 $(hexadd 40 $(get_reg $1)) ;;
		$reg8) assemble fe $(hexadd c0 $(get_reg $1)) ;;
		*) return 1 ;;
	esac
}

instr_dec() {
	args 1 || return 1
	case "$1" in
		$reg32) assemble $(hexadd 48 $(get_reg $1)) ;;
		$reg16) assemble 66 $(hexadd 48 $(get_reg $1)) ;;
		$reg8) assemble fe $(hexadd c8 $(get_reg $1)) ;;
		*) return 1 ;;
	esac
}

instr_xor() {
	args 2 || return 1
	case "$2" in
		$reg32)
			case "$1" in
				$reg32) assemble 31 $(hexadd c0 $(hexmult 8 $(get_reg $2)) $(get_reg $1)) ;;
				*) return 1 ;;
			esac
			;;
		$reg16)
			case "$1" in
				$reg16) assemble 66 31 $(hexadd c0 $(hexmult 8 $(get_reg $2)) $(get_reg $1)) ;;
				*) return 1 ;;
			esac
			;;
		$reg8)
			case "$1" in
				$reg8) assemble 30 $(hexadd c0 $(hexmult 8 $(get_reg $2)) $(get_reg $1)) ;;
				*) return 1 ;;
			esac
			;;
		*) return 1 ;;
	esac
}

instr_mov() {
	args 2 || return 1
	case "$2" in
		$reg32)
			case "$1" in
				$reg32) assemble 89 $(hexadd c0 $(hexmult 8 $(get_reg $2)) $(get_reg $1)) ;;
				*) return 1 ;;
			esac
			;;
		$reg16)
			case "$1" in
				$reg16) assemble 66 89 $(hexadd c0 $(hexmult 8 $(get_reg $2)) $(get_reg $1)) ;;
				*) return 1 ;;
			esac
			;;
		$reg8)
			case "$1" in
				$reg8) assemble 88 $(hexadd c0 $(hexmult 8 $(get_reg $2)) $(get_reg $1)) ;;
				*) return 1 ;;
			esac
			;;
		*) return 1 ;;
	esac
}

instr_int() {
	args 1 || return 1
	case "$1" in
		3) assemble cc ;;
		$hex*|0x$hex*|$hex*h|$bin*b|$dec*d)
			tohex "$1" 1 || return 1
			assemble cd $(num "$1")
			;;
		*) return 1 ;;
	esac
}

instr_add() {
	:
}

instr_sub() {
	:
}

instr_call() {
	args 1 || return 1
	case "$1" in
		$reg32) assemble ff $(hexadd d0 $(get_reg $1)) ;;
		$reg16) assemble 66 ff $(hexadd d0 $(get_reg $1)) ;;
		*) return 1 ;;
	esac
}

instr_jmp() {
	args 1 || return 1
	case "$1" in
		$reg32) assemble ff $(hexadd e0 $(get_reg $1)) ;;
		$reg16) assemble 66 ff $(hexadd e0 $(get_reg $1)) ;;
		*) return 1 ;;
	esac
}

instr_jz() {
	:
}

instr_jnz() {
	:
}

instr_jc() {
	:
}

instr_jnc() {
	:
}

instr_ja() {
	:
}

instr_jae() {
	:
}

instr_jb() {
	:
}

instr_jbe() {
	:
}

instr_jg() {
	:
}

instr_jge() {
	:
}

instr_jl() {
	:
}

instr_jle() {
	:
}

instr_foo() {
	:
}

instr_foo() {
	:
}

instr_foo() {
	:
}

instr_foo() {
	:
}

instr_foo() {
	:
}

instr_foo() {
	:
}

instr_foo() {
	:
}


